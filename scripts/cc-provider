#!/usr/bin/env bash
set -euo pipefail

CLAUDE_DIR="${CLAUDE_DIR:-$HOME/.claude}"
SETTINGS_FILE="$CLAUDE_DIR/settings.json"
LOCAL_FILE="$CLAUDE_DIR/settings.local.json"
PROFILES_DIR="$CLAUDE_DIR/profiles"
BACKUPS_DIR="$CLAUDE_DIR/backups"

KIMI_SECRETS_FILE="$PROFILES_DIR/kimi-secrets.json"
MINIMAX_SECRETS_FILE="$PROFILES_DIR/minimax-secrets.json"
OLLAMA_SECRETS_FILE="$PROFILES_DIR/ollama-secrets.json"
ZAI_SECRETS_FILE="$PROFILES_DIR/zai-secrets.json"

KIMI_MODEL="${KIMI_MODEL:-kimi-for-coding}"
KIMI_BASE_URL_DEFAULT="${KIMI_BASE_URL_DEFAULT:-https://api.kimi.com/coding/}"

MINIMAX_MODEL="${MINIMAX_MODEL:-MiniMax-M2.5}"
MINIMAX_BASE_URL_DEFAULT="${MINIMAX_BASE_URL_DEFAULT:-https://api.minimax.io/anthropic}"

OLLAMA_MODEL="${OLLAMA_MODEL:-qwen3-coder}"
OLLAMA_BASE_URL_DEFAULT="${OLLAMA_BASE_URL_DEFAULT:-http://localhost:11434/anthropic}"
OLLAMA_AUTH_TOKEN_DEFAULT="${OLLAMA_AUTH_TOKEN_DEFAULT:-ollama}"

ZAI_BASE_URL_DEFAULT="${ZAI_BASE_URL_DEFAULT:-https://api.z.ai/api/anthropic}"
ZAI_HAIKU_MODEL="${ZAI_HAIKU_MODEL:-GLM-4.5-Air}"
ZAI_SONNET_MODEL="${ZAI_SONNET_MODEL:-GLM-4.7}"
ZAI_OPUS_MODEL="${ZAI_OPUS_MODEL:-GLM-4.7}"
ZAI_CLAUDE_MODEL="${ZAI_CLAUDE_MODEL:-sonnet}"
GSD_TOOLS_BIN="${GSD_TOOLS_BIN:-$HOME/.claude/get-shit-done/bin/gsd-tools.cjs}"
GSD_DEFAULTS_FILE="${GSD_DEFAULTS_FILE:-$HOME/.gsd/defaults.json}"

print_usage() {
  cat <<'USAGE'
Usage:
  cc-provider status
  cc-provider kimi
  cc-provider claude
  cc-provider minimax
  cc-provider mini
  cc-provider ollama
  cc-provider zai

Aliases:
  cc-kimi
  cc-claude
  cc-mini
  cc-minimax
  cc-ollama
  cc-zai
USAGE
}

is_valid_gsd_profile() {
  local profile="$1"
  [[ "$profile" == "quality" || "$profile" == "balanced" || "$profile" == "budget" ]]
}

gsd_profile_for_provider() {
  local provider="$1"
  case "$provider" in
  claude)
    printf '%s' "${GSD_PROFILE_CLAUDE:-balanced}"
    ;;
  kimi)
    printf '%s' "${GSD_PROFILE_KIMI:-budget}"
    ;;
  minimax)
    printf '%s' "${GSD_PROFILE_MINIMAX:-budget}"
    ;;
  zai)
    printf '%s' "${GSD_PROFILE_ZAI:-budget}"
    ;;
  ollama)
    printf '%s' "${GSD_PROFILE_OLLAMA:-budget}"
    ;;
  *)
    printf '%s' "${GSD_PROFILE_DEFAULT:-balanced}"
    ;;
  esac
}

sync_gsd_profile() {
  local provider="$1"
  local target_profile
  local project_dir
  local project_config
  local project_updated="no"
  local project_reason="not_applicable"
  local defaults_updated="no"
  local defaults_reason="ok"

  target_profile="$(gsd_profile_for_provider "$provider")"
  if ! is_valid_gsd_profile "$target_profile"; then
    echo "Warning: Invalid GSD profile '$target_profile' for provider '$provider'. Falling back to 'balanced'."
    target_profile="balanced"
  fi

  project_dir="${CC_PROVIDER_GSD_CWD:-$PWD}"
  project_config="$project_dir/.planning/config.json"

  if [[ ! -f "$GSD_TOOLS_BIN" ]]; then
    project_reason="gsd_tools_not_found"
  elif [[ ! -d "$project_dir" ]]; then
    project_reason="project_dir_not_found"
  elif [[ -d "$project_dir/.planning" || -f "$project_config" ]]; then
    if (cd "$project_dir" && node "$GSD_TOOLS_BIN" config-set model_profile "$target_profile" >/dev/null 2>&1); then
      project_updated="yes"
      project_reason="updated"
    else
      project_reason="config_set_failed"
    fi
  else
    project_reason="planning_not_found"
  fi

  mkdir -p "$(dirname "$GSD_DEFAULTS_FILE")"
  if [[ ! -f "$GSD_DEFAULTS_FILE" ]]; then
    printf '{}\n' >"$GSD_DEFAULTS_FILE"
  fi
  if jq --arg profile "$target_profile" '.model_profile = $profile' "$GSD_DEFAULTS_FILE" >"$GSD_DEFAULTS_FILE.tmp"; then
    mv "$GSD_DEFAULTS_FILE.tmp" "$GSD_DEFAULTS_FILE"
    defaults_updated="yes"
  else
    rm -f "$GSD_DEFAULTS_FILE.tmp"
    defaults_reason="defaults_update_failed"
  fi

  cat <<MSG
GSD profile sync
- provider: $provider
- target model_profile: $target_profile
- project config path: $project_config
- project config updated: $project_updated ($project_reason)
- defaults file: $GSD_DEFAULTS_FILE
- defaults updated: $defaults_updated ($defaults_reason)
MSG
}

ensure_json_file() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    printf '{}\n' >"$file"
  fi
  if ! jq empty "$file" >/dev/null 2>&1; then
    echo "Invalid JSON: $file" >&2
    exit 1
  fi
}

write_json() {
  local src="$1"
  local jq_filter="$2"
  shift 2
  local tmp
  tmp="$(mktemp)"
  jq "$jq_filter" "$@" "$src" >"$tmp"
  mv "$tmp" "$src"
}

write_json_args() {
  local src="$1"
  local jq_filter="$2"
  shift 2
  local tmp
  tmp="$(mktemp)"
  jq "$@" "$jq_filter" "$src" >"$tmp"
  mv "$tmp" "$src"
}

backup_current() {
  local timestamp
  timestamp="$(date +%Y%m%d-%H%M%S)"
  mkdir -p "$BACKUPS_DIR"
  local backup_dir
  backup_dir="$(mktemp -d "$BACKUPS_DIR/provider-switch-$timestamp-XXXXXX")"

  [[ -f "$SETTINGS_FILE" ]] && cp -a "$SETTINGS_FILE" "$backup_dir/settings.json"
  [[ -f "$LOCAL_FILE" ]] && cp -a "$LOCAL_FILE" "$backup_dir/settings.local.json"

  echo "$backup_dir"
}

extract_secret() {
  local file="$1"
  local key="$2"
  if [[ -f "$file" ]]; then
    jq -r --arg key "$key" '.env[$key] // empty' "$file"
  else
    printf ''
  fi
}

active_api_key() {
  extract_secret "$LOCAL_FILE" "ANTHROPIC_API_KEY"
}

active_auth_token() {
  local token
  token="$(extract_secret "$LOCAL_FILE" "ANTHROPIC_AUTH_TOKEN")"
  if [[ -n "$token" ]]; then
    printf '%s' "$token"
    return 0
  fi
  extract_secret "$LOCAL_FILE" "ANTHROPIC_API_KEY"
}

active_base_url() {
  extract_secret "$LOCAL_FILE" "ANTHROPIC_BASE_URL"
}

current_model() {
  jq -r '.model // "unset"' "$SETTINGS_FILE"
}

current_provider_guess() {
  local model
  local model_pin
  local base_url
  model="$(current_model)"
  model_pin="$(jq -r '.env.ANTHROPIC_MODEL // empty' "$SETTINGS_FILE")"
  base_url="$(active_base_url)"

  if [[ "$model" == "$KIMI_MODEL" || "$model_pin" == "$KIMI_MODEL" ]] || [[ "$base_url" == *"api.kimi.com"* ]]; then
    echo "kimi"
    return 0
  fi

  if [[ "$base_url" == *"api.z.ai"* ]]; then
    echo "zai"
    return 0
  fi

  if [[ "$model" == "$OLLAMA_MODEL" || "$model_pin" == "$OLLAMA_MODEL" ]] || [[ "$base_url" == *"11434/anthropic"* ]]; then
    echo "ollama"
    return 0
  fi

  if [[ "$model" == "$MINIMAX_MODEL" || "$model_pin" == "$MINIMAX_MODEL" ]] || [[ "$base_url" == *"minimax"* ]]; then
    echo "minimax"
    return 0
  fi

  if [[ "$model" == "sonnet" || "$model" == "opus" || "$model" == "haiku" || "$model" == claude-* ]]; then
    echo "claude"
    return 0
  fi

  echo "unknown"
}

zai_profile_is_fresh() {
  local model
  local base_url
  local model_pin
  local small_model_pin
  local haiku_model
  local sonnet_model
  local opus_model

  model="$(current_model)"
  base_url="$(active_base_url)"
  model_pin="$(jq -r '.env.ANTHROPIC_MODEL // empty' "$SETTINGS_FILE")"
  small_model_pin="$(jq -r '.env.ANTHROPIC_SMALL_FAST_MODEL // empty' "$SETTINGS_FILE")"
  haiku_model="$(jq -r '.env.ANTHROPIC_DEFAULT_HAIKU_MODEL // empty' "$SETTINGS_FILE")"
  sonnet_model="$(jq -r '.env.ANTHROPIC_DEFAULT_SONNET_MODEL // empty' "$SETTINGS_FILE")"
  opus_model="$(jq -r '.env.ANTHROPIC_DEFAULT_OPUS_MODEL // empty' "$SETTINGS_FILE")"

  [[ "$model" == "$ZAI_CLAUDE_MODEL" ]] || return 1
  [[ "$base_url" == *"api.z.ai"* ]] || return 1
  [[ -z "$model_pin" ]] || return 1
  [[ -z "$small_model_pin" ]] || return 1
  [[ "$haiku_model" == "$ZAI_HAIKU_MODEL" ]] || return 1
  [[ "$sonnet_model" == "$ZAI_SONNET_MODEL" ]] || return 1
  [[ "$opus_model" == "$ZAI_OPUS_MODEL" ]] || return 1

  return 0
}

fmt_value() {
  local value="${1:-}"
  if [[ -n "$value" ]]; then
    printf '%s' "$value"
  else
    printf '<none>'
  fi
}

print_already_active_notice() {
  local target="$1"
  local model="$2"
  local base_url="$3"

  cat <<MSG
No switch needed.
- Claude Code is already using '$target' profile.
- model: $model
- API base URL: $(fmt_value "$base_url")
- notice: CC zaten su an $target kullaniyor.
MSG
}

print_transition_notice() {
  local previous_provider="$1"
  local previous_base_url="$2"
  local current_provider
  local current_base_url

  current_provider="$(current_provider_guess)"
  current_base_url="$(active_base_url)"

  cat <<MSG
Switch transition summary
- previous provider: $previous_provider
- current provider: $current_provider
- previous API base URL: $(fmt_value "$previous_base_url")
- current API base URL: $(fmt_value "$current_base_url")
- notice: onceki api/provider '$previous_provider', simdiki '$current_provider'.
MSG
}

stash_secrets() {
  local dest_file="$1"
  local auth_token="$2"
  local base_url="$3"

  if [[ -z "$auth_token" && -z "$base_url" ]]; then
    return 0
  fi

  mkdir -p "$PROFILES_DIR"

  local tmp
  tmp="$(mktemp)"
  jq -n --arg token "$auth_token" --arg url "$base_url" '{env:{ANTHROPIC_AUTH_TOKEN:$token,ANTHROPIC_API_KEY:$token,ANTHROPIC_BASE_URL:$url}}' >"$tmp"
  install -m 600 "$tmp" "$dest_file"
  rm -f "$tmp"
}

restore_secret() {
  local src_file="$1"
  local key="$2"
  if [[ ! -f "$src_file" ]]; then
    printf ''
    return 0
  fi
  jq -r --arg key "$key" '.env[$key] // empty' "$src_file"
}

save_active_provider_secrets() {
  local provider
  local auth_token
  local base_url

  provider="$(current_provider_guess)"
  auth_token="$(active_auth_token)"
  base_url="$(active_base_url)"

  case "$provider" in
  kimi)
    stash_secrets "$KIMI_SECRETS_FILE" "$auth_token" "$base_url"
    ;;
  minimax)
    stash_secrets "$MINIMAX_SECRETS_FILE" "$auth_token" "$base_url"
    ;;
  ollama)
    stash_secrets "$OLLAMA_SECRETS_FILE" "$auth_token" "$base_url"
    ;;
  zai)
    stash_secrets "$ZAI_SECRETS_FILE" "$auth_token" "$base_url"
    ;;
  *)
    ;;
  esac
}

switch_to_claude() {
  mkdir -p "$CLAUDE_DIR"
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local previous_provider
  local previous_model
  local previous_base_url
  local backup_dir

  previous_provider="$(current_provider_guess)"
  previous_model="$(current_model)"
  previous_base_url="$(active_base_url)"

  if [[ "$previous_provider" == "claude" ]]; then
    sync_gsd_profile "claude"
    print_already_active_notice "claude" "$previous_model" "$previous_base_url"
    return 0
  fi

  backup_dir="$(backup_current)"

  save_active_provider_secrets

  write_json "$SETTINGS_FILE" '
    def add_once($x): if index($x) == null then . + [$x] else . end;
    .model = "sonnet"
    | .env = (.env // {})
    | .env.ENABLE_TOOL_SEARCH = "auto:1"
    | .env |= with_entries(select(
        .key != "ANTHROPIC_MODEL"
        and .key != "ANTHROPIC_SMALL_FAST_MODEL"
        and .key != "ANTHROPIC_DEFAULT_HAIKU_MODEL"
        and .key != "ANTHROPIC_DEFAULT_SONNET_MODEL"
        and .key != "ANTHROPIC_DEFAULT_OPUS_MODEL"
        and .key != "CLAUDE_CODE_SUBAGENT_MODEL"
      ))
    | .permissions = (.permissions // {})
    | .permissions.allow = ((.permissions.allow // []) | add_once("ToolSearch"))
    | .permissions.deny = ((.permissions.deny // []) | map(select(. != "ToolSearch")))
  '

  write_json "$LOCAL_FILE" '
    .env = (.env // {})
    | .env |= with_entries(select(.key != "ANTHROPIC_API_KEY" and .key != "ANTHROPIC_AUTH_TOKEN" and .key != "ANTHROPIC_BASE_URL"))
  '

  cat <<MSG
Switched to Claude profile.
Backup: $backup_dir
Notes:
- Provider API credentials were removed from active local env to avoid auth conflicts.
- If needed, run: claude /login
MSG

  sync_gsd_profile "claude"

  print_transition_notice "$previous_provider" "$previous_base_url"

  if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
    cat <<WARN
Warning:
- Current shell still exports ANTHROPIC_API_KEY.
- For pure claude.ai flow, run: unset ANTHROPIC_API_KEY
WARN
  fi
}

switch_to_kimi() {
  mkdir -p "$CLAUDE_DIR"
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local previous_provider
  local previous_model
  local previous_base_url
  local backup_dir
  local current_provider
  local api_key
  local base_url

  previous_provider="$(current_provider_guess)"
  previous_model="$(current_model)"
  previous_base_url="$(active_base_url)"

  if [[ "$previous_provider" == "kimi" ]]; then
    sync_gsd_profile "kimi"
    print_already_active_notice "kimi" "$previous_model" "$previous_base_url"
    return 0
  fi

  backup_dir="$(backup_current)"
  current_provider="$(current_provider_guess)"

  save_active_provider_secrets

  if [[ "$current_provider" == "kimi" ]]; then
    api_key="$(active_api_key)"
    base_url="$(active_base_url)"
  else
    api_key="$(restore_secret "$KIMI_SECRETS_FILE" "ANTHROPIC_API_KEY")"
    base_url="$(restore_secret "$KIMI_SECRETS_FILE" "ANTHROPIC_BASE_URL")"
  fi

  if [[ -z "$base_url" ]]; then
    base_url="$KIMI_BASE_URL_DEFAULT"
  fi

  write_json_args "$LOCAL_FILE" '
    .env = (.env // {})
    | .env.ANTHROPIC_BASE_URL = $base_url
    | .env |= with_entries(select(.key != "ANTHROPIC_AUTH_TOKEN"))
    | if $api_key == "" then
        (.env |= with_entries(select(.key != "ANTHROPIC_API_KEY")))
      else
        (.env.ANTHROPIC_API_KEY = $api_key)
      end
  ' --arg api_key "$api_key" --arg base_url "$base_url"

  write_json_args "$SETTINGS_FILE" '
    .model = $model
    | .env = (.env // {})
    | .env.ENABLE_TOOL_SEARCH = "0"
    | .env.ANTHROPIC_DEFAULT_HAIKU_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_SONNET_MODEL = $model
    | .env.CLAUDE_CODE_SUBAGENT_MODEL = $model
    | .permissions = (.permissions // {})
    | .permissions.allow = ((.permissions.allow // []) | map(select(. != "ToolSearch")))
    | .permissions.deny = ((.permissions.deny // []) | if index("ToolSearch") == null then . + ["ToolSearch"] else . end)
  ' --arg model "$KIMI_MODEL"

  if [[ -z "$api_key" ]]; then
    cat <<WARN
Switched to Kimi profile.
Backup: $backup_dir
Warning: No Kimi API key found in active config or saved profile.
Set ANTHROPIC_API_KEY manually (or run your Kimi auth flow) before using Claude Code.
WARN
  else
    cat <<MSG
Switched to Kimi profile.
Backup: $backup_dir
Notes:
- Kimi model pins and base URL were applied.
- ToolSearch was disabled for Kimi compatibility.
MSG
  fi

  sync_gsd_profile "kimi"

  print_transition_notice "$previous_provider" "$previous_base_url"
}

switch_to_minimax() {
  mkdir -p "$CLAUDE_DIR"
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local previous_provider
  local previous_model
  local previous_base_url
  local backup_dir
  local current_provider
  local auth_token
  local base_url

  previous_provider="$(current_provider_guess)"
  previous_model="$(current_model)"
  previous_base_url="$(active_base_url)"

  if [[ "$previous_provider" == "minimax" ]]; then
    sync_gsd_profile "minimax"
    print_already_active_notice "minimax" "$previous_model" "$previous_base_url"
    return 0
  fi

  backup_dir="$(backup_current)"
  current_provider="$(current_provider_guess)"

  save_active_provider_secrets

  if [[ "$current_provider" == "minimax" ]]; then
    auth_token="$(active_auth_token)"
    base_url="$(active_base_url)"
  else
    auth_token="$(restore_secret "$MINIMAX_SECRETS_FILE" "ANTHROPIC_AUTH_TOKEN")"
    if [[ -z "$auth_token" ]]; then
      auth_token="$(restore_secret "$MINIMAX_SECRETS_FILE" "ANTHROPIC_API_KEY")"
    fi
    base_url="$(restore_secret "$MINIMAX_SECRETS_FILE" "ANTHROPIC_BASE_URL")"
  fi

  if [[ -z "$base_url" ]] || [[ "$base_url" == *"api.minimax.chat"* ]]; then
    base_url="$MINIMAX_BASE_URL_DEFAULT"
  fi

  write_json_args "$LOCAL_FILE" '
    .env = (.env // {})
    | .env.ANTHROPIC_BASE_URL = $base_url
    | if $auth_token == "" then
        (.env |= with_entries(select(.key != "ANTHROPIC_AUTH_TOKEN" and .key != "ANTHROPIC_API_KEY")))
      else
        (.env.ANTHROPIC_AUTH_TOKEN = $auth_token)
        | (.env |= with_entries(select(.key != "ANTHROPIC_API_KEY")))
      end
  ' --arg auth_token "$auth_token" --arg base_url "$base_url"

  write_json_args "$SETTINGS_FILE" '
    def add_once($x): if index($x) == null then . + [$x] else . end;
    .model = $model
    | .env = (.env // {})
    | .env.ENABLE_TOOL_SEARCH = "auto:1"
    | .env.ANTHROPIC_MODEL = $model
    | .env.ANTHROPIC_SMALL_FAST_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_HAIKU_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_SONNET_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_OPUS_MODEL = $model
    | .env.CLAUDE_CODE_SUBAGENT_MODEL = $model
    | .permissions = (.permissions // {})
    | .permissions.allow = ((.permissions.allow // []) | add_once("ToolSearch"))
    | .permissions.deny = ((.permissions.deny // []) | map(select(. != "ToolSearch")))
  ' --arg model "$MINIMAX_MODEL"

  if [[ -z "$auth_token" ]]; then
    cat <<WARN
Switched to MiniMax profile.
Backup: $backup_dir
Warning: No MiniMax auth token found in active config or saved profile.
Set ANTHROPIC_AUTH_TOKEN manually for your MiniMax endpoint before using Claude Code.
WARN
  else
    cat <<MSG
Switched to MiniMax profile.
Backup: $backup_dir
Notes:
- MiniMax model pins and base URL were applied.
- ToolSearch remains enabled by default in this profile.
MSG
  fi

  sync_gsd_profile "minimax"

  print_transition_notice "$previous_provider" "$previous_base_url"
}

switch_to_ollama() {
  mkdir -p "$CLAUDE_DIR"
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local previous_provider
  local previous_model
  local previous_base_url
  local backup_dir
  local current_provider
  local auth_token
  local base_url

  previous_provider="$(current_provider_guess)"
  previous_model="$(current_model)"
  previous_base_url="$(active_base_url)"

  if [[ "$previous_provider" == "ollama" ]]; then
    sync_gsd_profile "ollama"
    print_already_active_notice "ollama" "$previous_model" "$previous_base_url"
    return 0
  fi

  backup_dir="$(backup_current)"
  current_provider="$(current_provider_guess)"

  save_active_provider_secrets

  if [[ "$current_provider" == "ollama" ]]; then
    auth_token="$(active_auth_token)"
    base_url="$(active_base_url)"
  else
    auth_token="$(restore_secret "$OLLAMA_SECRETS_FILE" "ANTHROPIC_AUTH_TOKEN")"
    if [[ -z "$auth_token" ]]; then
      auth_token="$(restore_secret "$OLLAMA_SECRETS_FILE" "ANTHROPIC_API_KEY")"
    fi
    base_url="$(restore_secret "$OLLAMA_SECRETS_FILE" "ANTHROPIC_BASE_URL")"
  fi

  if [[ -z "$base_url" ]]; then
    base_url="$OLLAMA_BASE_URL_DEFAULT"
  fi

  if [[ -z "$auth_token" ]]; then
    auth_token="$OLLAMA_AUTH_TOKEN_DEFAULT"
  fi

  write_json_args "$LOCAL_FILE" '
    .env = (.env // {})
    | .env.ANTHROPIC_BASE_URL = $base_url
    | .env.ANTHROPIC_AUTH_TOKEN = $auth_token
    | .env |= with_entries(select(.key != "ANTHROPIC_API_KEY"))
  ' --arg auth_token "$auth_token" --arg base_url "$base_url"

  write_json_args "$SETTINGS_FILE" '
    def add_once($x): if index($x) == null then . + [$x] else . end;
    .model = $model
    | .env = (.env // {})
    | .env.ENABLE_TOOL_SEARCH = "auto:1"
    | .env.API_TIMEOUT_MS = "3000000"
    | .env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC = 1
    | .env.ANTHROPIC_MODEL = $model
    | .env.ANTHROPIC_SMALL_FAST_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_HAIKU_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_SONNET_MODEL = $model
    | .env.ANTHROPIC_DEFAULT_OPUS_MODEL = $model
    | .env.CLAUDE_CODE_SUBAGENT_MODEL = $model
    | .permissions = (.permissions // {})
    | .permissions.allow = ((.permissions.allow // []) | add_once("ToolSearch"))
    | .permissions.deny = ((.permissions.deny // []) | map(select(. != "ToolSearch")))
  ' --arg model "$OLLAMA_MODEL"

  cat <<MSG
Switched to Ollama profile.
Backup: $backup_dir
Notes:
- Ollama Anthropic-compatible base URL and auth token were applied.
- Default model pin: $OLLAMA_MODEL (override with OLLAMA_MODEL before switching).
- Ensure Ollama is running and model is available (e.g. ollama pull $OLLAMA_MODEL).
MSG

  sync_gsd_profile "ollama"

  print_transition_notice "$previous_provider" "$previous_base_url"
}

switch_to_zai() {
  mkdir -p "$CLAUDE_DIR"
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local previous_provider
  local previous_model
  local previous_base_url
  local backup_dir
  local current_provider
  local auth_token
  local base_url

  previous_provider="$(current_provider_guess)"
  previous_model="$(current_model)"
  previous_base_url="$(active_base_url)"

  if [[ "$previous_provider" == "zai" ]]; then
    if zai_profile_is_fresh; then
      sync_gsd_profile "zai"
      print_already_active_notice "zai" "$previous_model" "$previous_base_url"
      return 0
    fi
    echo "z.ai profile already active, but stale model pins detected. Reapplying profile settings..."
  fi

  backup_dir="$(backup_current)"
  current_provider="$(current_provider_guess)"

  save_active_provider_secrets

  if [[ "$current_provider" == "zai" ]]; then
    auth_token="$(active_auth_token)"
    base_url="$(active_base_url)"
  else
    auth_token="$(restore_secret "$ZAI_SECRETS_FILE" "ANTHROPIC_AUTH_TOKEN")"
    if [[ -z "$auth_token" ]]; then
      auth_token="$(restore_secret "$ZAI_SECRETS_FILE" "ANTHROPIC_API_KEY")"
    fi
    base_url="$(restore_secret "$ZAI_SECRETS_FILE" "ANTHROPIC_BASE_URL")"
  fi

  if [[ -z "$base_url" ]]; then
    base_url="$ZAI_BASE_URL_DEFAULT"
  fi

  write_json_args "$LOCAL_FILE" '
    .env = (.env // {})
    | .env.ANTHROPIC_BASE_URL = $base_url
    | .env |= with_entries(select(.key != "ANTHROPIC_MODEL" and .key != "ANTHROPIC_SMALL_FAST_MODEL"))
    | if $auth_token == "" then
        (.env |= with_entries(select(.key != "ANTHROPIC_AUTH_TOKEN" and .key != "ANTHROPIC_API_KEY")))
      else
        (.env.ANTHROPIC_AUTH_TOKEN = $auth_token)
        | (.env |= with_entries(select(.key != "ANTHROPIC_API_KEY")))
      end
  ' --arg auth_token "$auth_token" --arg base_url "$base_url"

  write_json_args "$SETTINGS_FILE" '
    def add_once($x): if index($x) == null then . + [$x] else . end;
    .model = $claude_model
    | .env = (.env // {})
    | .env.ENABLE_TOOL_SEARCH = "auto:1"
    | .env |= with_entries(select(.key != "ANTHROPIC_MODEL" and .key != "ANTHROPIC_SMALL_FAST_MODEL"))
    | .env.ANTHROPIC_DEFAULT_HAIKU_MODEL = $haiku_model
    | .env.ANTHROPIC_DEFAULT_SONNET_MODEL = $sonnet_model
    | .env.ANTHROPIC_DEFAULT_OPUS_MODEL = $opus_model
    | .env.CLAUDE_CODE_SUBAGENT_MODEL = $sonnet_model
    | .permissions = (.permissions // {})
    | .permissions.allow = ((.permissions.allow // []) | add_once("ToolSearch"))
    | .permissions.deny = ((.permissions.deny // []) | map(select(. != "ToolSearch")))
  ' \
    --arg claude_model "$ZAI_CLAUDE_MODEL" \
    --arg haiku_model "$ZAI_HAIKU_MODEL" \
    --arg sonnet_model "$ZAI_SONNET_MODEL" \
    --arg opus_model "$ZAI_OPUS_MODEL"

  if [[ -z "$auth_token" ]]; then
    cat <<WARN
Switched to z.ai profile.
Backup: $backup_dir
Warning: No z.ai auth token found in active config or saved profile.
Set ANTHROPIC_AUTH_TOKEN manually for z.ai endpoint before using Claude Code.
WARN
  else
    cat <<MSG
Switched to z.ai profile.
Backup: $backup_dir
Notes:
- z.ai Anthropic-compatible endpoint and model mapping were applied.
- Default mapping: haiku=$ZAI_HAIKU_MODEL, sonnet=$ZAI_SONNET_MODEL, opus=$ZAI_OPUS_MODEL
- For GLM-5 (if your plan supports it), set ZAI_SONNET_MODEL=GLM-5 and/or ZAI_OPUS_MODEL=GLM-5 before switching.
MSG
  fi

  sync_gsd_profile "zai"

  print_transition_notice "$previous_provider" "$previous_base_url"
}

status() {
  ensure_json_file "$SETTINGS_FILE"
  ensure_json_file "$LOCAL_FILE"

  local model
  local base_url
  local has_auth_token
  local toolsearch_allow
  local toolsearch_deny
  local profile
  local shell_auth_token="no"

  model="$(current_model)"
  base_url="$(active_base_url)"
  has_auth_token="$(jq -r 'if ((.env.ANTHROPIC_AUTH_TOKEN // .env.ANTHROPIC_API_KEY // "") == "" ) then "no" else "yes" end' "$LOCAL_FILE")"
  toolsearch_allow="$(jq -r 'if ((.permissions.allow // []) | index("ToolSearch")) == null then "no" else "yes" end' "$SETTINGS_FILE")"
  toolsearch_deny="$(jq -r 'if ((.permissions.deny // []) | index("ToolSearch")) == null then "no" else "yes" end' "$SETTINGS_FILE")"
  profile="$(current_provider_guess)"

  if [[ -n "${ANTHROPIC_AUTH_TOKEN:-}" || -n "${ANTHROPIC_API_KEY:-}" ]]; then
    shell_auth_token="yes"
  fi

  cat <<MSG
Provider Status
- Active profile guess: $profile
- model: $model
- base_url present: $( [[ -n "$base_url" ]] && echo yes || echo no )
- auth token present in active env: $has_auth_token
- shell auth token exported: $shell_auth_token
- ToolSearch allowed: $toolsearch_allow
- ToolSearch denied: $toolsearch_deny
- settings: $SETTINGS_FILE
- settings local: $LOCAL_FILE
- kimi secrets stash: $KIMI_SECRETS_FILE
- minimax secrets stash: $MINIMAX_SECRETS_FILE
- ollama secrets stash: $OLLAMA_SECRETS_FILE
- z.ai secrets stash: $ZAI_SECRETS_FILE
MSG

  if command -v claude >/dev/null 2>&1; then
    local auth_status
    auth_status="$(claude auth status 2>/dev/null || true)"
    if [[ -n "$auth_status" ]]; then
      local logged_in auth_method
      logged_in="$(printf '%s' "$auth_status" | jq -r 'if has("loggedIn") then (.loggedIn | tostring) else "unknown" end' 2>/dev/null || printf 'unknown')"
      auth_method="$(printf '%s' "$auth_status" | jq -r '.authMethod // "unknown"' 2>/dev/null || printf 'unknown')"
      echo "- claude auth: loggedIn=$logged_in, authMethod=$auth_method"
    fi
  fi
}

main() {
  local cmd="${1:-status}"

  case "$cmd" in
  status)
    status
    ;;
  kimi)
    switch_to_kimi
    ;;
  claude)
    switch_to_claude
    ;;
  minimax|mini)
    switch_to_minimax
    ;;
  ollama)
    switch_to_ollama
    ;;
  zai|glm)
    switch_to_zai
    ;;
  -h|--help|help)
    print_usage
    ;;
  *)
    echo "Unknown command: $cmd" >&2
    print_usage >&2
    exit 1
    ;;
  esac
}

main "$@"
